[
  {
    "Text": "Название среды \u2014 общеязыковая среда выполнения (Common Language Runtime, CLR) \u2014 говорит само за себя: это среда выполнения, которая подходит для разных языков программирования. Основные возможности CLR (управление памятью, загрузка сборок, безопасность, обработка исключений, синхронизация) доступны в любых языках программирования, использующих эту среду. Например, при обработке ошибок среда выполнения опирается на исключения, а значит, во всех языках программирования, использующих эту среду выполнения, сообщения об ошибках передаются при помощи механизма исключений. Или, например, среда выполнения позволяет создавать программные потоки, а значит, во всех языках программирования, использующих эту среду, тоже могут создаваться потоки.",
    "Chapter": 1,
    "Page": 28
  },
  {
    "Text": "Каждый компилятор, предназначенный для CLR, помимо генерирования IL-кода, должен также создавать полные метаданные (metadata) для каждого управляемого модуля. Проще говоря, метаданные \u2014 это набор таблиц данных, описывающих то, что определено в модуле, например типы и их члены. В метаданных также есть таблицы, указывающие, на что ссылается управляемый модуль, например на импортируемые типы и их члены. ",
    "Chapter": 1,
    "Page": 31
  },
  {
    "Text": "JIT-компилятор хранит машинные команды в динамической памяти. Это зна- чит, что скомпилированный код уничтожается по завершении работы приложения. Для повторного вызова приложения или для параллельного запуска его второго экземпляра (в другом процессе операционной системы) JIT-компилятору придется заново скомпилировать IL-код в машинные команды. В зависимости от приложения это может привести к существенному повышению затрат памяти по сравнению с низкоуровневыми приложением, у которых находящийся в памяти код доступен только для чтения и совместно используется всеми экземплярами приложения",
    "Chapter": 1,
    "Page": 41
  },
  {
    "Text": "IL является стековым языком; это означает, что все его инструкции заносят операнды в исполнительный стек и извлекают результаты из стека. IL не содержит инструкций для работы с регистрами, и это упрощает создание новых языков и компиляторов, генерирующих код для CLR",
    "Chapter": 1,
    "Page": 44
  },
  {
    "Text": "Да, IL-код работает на более высоком уровне, чем большинство других ассемблеров, и в общем случае дизассемблирование IL-кода выполняется относительно просто. Однако при реализации кода, работающего на стороне сервера (веб-служба, веб-форма или хранимая процедура), сборка находится на сервере. Поскольку по- сторонний не сможет обратиться к сборке, он не сможет и воспользоваться любыми программами для просмотра IL \u2014 ваша интеллектуальная собственность в полной безопасности",
    "Chapter": 1,
    "Page": 46
  },
  {
    "Text": "В CLR каждый объект прямо или косвенно является производным от System.Object.",
    "Chapter": 4,
    "Page": 122
  },
  {
    "Text": "Одна из важнейших особенностей CLR \u2014 безопасность типов (type safety). Во время выполнения программы среде CLR всегда известен тип объекта. Программист всегда может точно определить тип объекта при помощи метода GetType. Поскольку это невиртуальный метод, никакой тип не сможет сообщить о себе ложные сведения. Например, тип Employee не может переопределить метод GetType, чтобы тот вернул тип SuperHero.",
    "Chapter": 4,
    "Page": 124
  },
  {
    "Text": "Пространство имен и сборка (файл, в котором реализован тип) не обязательно связаны друг с другом. В частности, различные типы, принадлежащие одному пространству имен, могут быть реализованы в разных сборках. Например, тип System.IO.FileStream реализован в сборке MSCorLib dll, а тип System. IO.FileSystemWatcher \u2014 в сборке System dll. На самом деле, сборка System IO dll в .NET Framework даже не поставляется.",
    "Chapter": 4,
    "Page": 132
  },
  {
    "Text": "Конечно, объект-тип System.Type сам является объектом и поэтому также содержит указатель на объект-тип; значит, закономерно поинтересоваться, на что ссылается этот указатель. А ссылается он на самого себя, так как объект-тип System. Type сам по себе является \u00ABэкземпляром\u00BB объекта-типа. Теперь становится понятно, как устроена и работает вся система типов в CLR. Кстати, метод GetType типа System.Object просто возвращает адрес, хранящийся в указателе на объект-тип заданного объекта. Иначе говоря, метод GetType возвращает указатель на объект- тип указанного объекта и именно поэтому можно определить истинный тип любого объекта в системе (включая объекты-типы)",
    "Chapter": 4,
    "Page": 141
  },
  {
    "Text": "Мне попадались разработчики, не знавшие, какое ключевое слово использовать им в коде: string или String. В C# это не важно, так как ключевое слово string в точности преобразуется в FCL-тип System.String. Я также слышал, что некоторые разработчики говорили о том, что в 32-разрядных операционных системах тип int представлялся 32-разрядным типом, а в 64-разрядных \u2014 64- разрядным типом. Это утверждение совершенно неверно: в C# тип int всегда преобразуется в System.Int32, поэтому он всегда представляется 32-разрядным типом безотносительно запущенной операционной системы. Использование ключевого слова Int32 в своем коде позволит избежать путаницы.",
    "Chapter": 5,
    "Page": 144
  },
  {
    "Text": "Пишущий на C# программист может сам решать, как обрабатывать переполнение; по умолчанию проверка переполнения отключена. Это значит, что компилятор генерирует для операций сложения, вычитания, умножения и преобразования IL- команды без проверки переполнения. В результате код выполняется быстро, но раз- работчик должен быть либо уверен в отсутствии переполнения, либо предусмотреть возможность его возникновения в своем коде. Чтобы включить механизм управления процессом обработки переполнения на этапе компиляции, добавьте в командную строку компилятора параметр /checked\u002B.",
    "Chapter": 5,
    "Page": 147
  },
  {
    "Text": "Тип System.Decimal стоит особняком. В отличие от многих языков программирования  (включая C# и Visual Basic), в CLR тип Decimal не относится к примитивным типам. В CLR нет IL-команд для работы со значениями типа Decimal. В документации по  NET  Framework сказано, что тип Decimal имеет открытые статические методы-члены Add, Subtract, Multiply, Divide и прочие, а также перегруженные операторы \u002B, -, *, / и т. д.",
    "Chapter": 5,
    "Page": 150
  },
  {
    "Text": "Все структуры являются прямыми потомками абстрактного типа System. ValueType, который, в свою очередь, является производным от типа System. Object. По умолчанию все значимые типы должны быть производными от System. ValueType. Все перечисления являются производными от типа System.Enum, про- изводного от System.ValueType. CLR и языки программирования по-разному работают с перечислениями.",
    "Chapter": 5,
    "Page": 151
  },
  {
    "Text": "При определении собственного значимого типа нельзя выбрать произвольный базовый тип, однако значимый тип может реализовать один или несколько выбранных вами интерфейсов. Кроме того, в CLR значимый тип является изолированным, то есть он не может служить базовым типом для какого-либо другого ссылочного или значимого типа. Поэтому, например, нельзя в описании нового типа указывать в качестве базовых типы Boolean, Char, Int32, Uint64, Single, Double, Decimal и т. д",
    "Chapter": 5,
    "Page": 151
  },
  {
    "Text": "Значимые типы являются производными от System.ValueType. Этот тип имеет те же методы, что и System.Object. Однако System.ValueType переопределяет метод Equals, который возвращает true, если значения полей в обоих объектах совпадают. Кроме того, в System.ValueType переопределен метод GetHashCode, который создает хеш-код по алгоритму, учитывающему значения полей экземпляра объекта. Из-за проблем с производительностью в реализации по умолчанию, определяя собственные значимые типы значений, надо переопределить и написать свою реализацию методов Equals и GetHashCode. О методах Equals и GetHashCode рассказано в конце этой главы.",
    "Chapter": 5,
    "Page": 154
  },
  {
    "Text": "Хотя неупакованные значимые типы не имеют указателя на типовой объект, вы все равно можете вызывать виртуальные методы (такие, как Equals, GetHashCode или ToString), унаследованные или прееопределенные этим типом. Если ваш значимый тип переопределяет один из этих виртуальных методов, CLR может вызвать метод невиртуально, потому что значимые типы неявно запечатываются и поэтому не могут выступать базовыми классами других типов. Кроме того, экземпляр значимого типа, используемый для вызова виртуального метода, не упаковывается. Но если ваше переопределение виртуального метода вызывает реализацию этого метода из базового типа, экземпляр значимого типа упаковывается при вызове реализации базового типа, чтобы в указателе this базового метода передавалась ссылка на объект в куче.",
    "Chapter": 5,
    "Page": 166
  },
  {
    "Text": "Разработчики FCL решили, что было бы чрезвычайно полезно иметь возможность добавления в хеш-таблицы любых экземпляров любых типов. С этой целью в System.Object включен виртуальный метод GetHashCode, позволяющий вычис- лить для любого объекта целочисленный (Int32) хеш-код.",
    "Chapter": 5,
    "Page": 175
  },
  {
    "Text": "Причина, по которой в типе должны быть определены оба метода \u2014 Equals и GetHashCode, \u2014 состоит в том, что реализация типов System.Collections. Hashtable, System.Collections.Generic.Dictionary и любых других коллекций требует, чтобы два равных объекта имели одинаковые значения хеш-кодов. По- этому, переопределяя Equals, нужно переопределить GetHashCode и обеспечить соответствие алгоритма, применяемого для вычисления равенства, алгоритму, используемому для вычисления хеш-кода объекта.",
    "Chapter": 5,
    "Page": 176
  },
  {
    "Text": "В определении метода GetHashCode нет особых хитростей. Однако для некоторых типов данных и их распределения в памяти бывает непросто подобрать алгоритм хеширования, который выдавал бы хорошо распределенный диапазон значений.",
    "Chapter": 5,
    "Page": 176
  },
  {
    "Text": "Реализация GetHashCode в System.Object ничего \u00ABне знает\u00BB о производных типах и их полях. Поэтому этот метод возвращает число, однозначно идентифицирующее объект в пределах домена приложений; при этом гарантируется, что это число не изменится на протяжении всей жизни объекта.",
    "Chapter": 5,
    "Page": 177
  },
  {
    "Text": "Объектно-ориентированное программирование (ООП) существует уже много лет. В поздние 70-е и ранние 80-е годы объектно-ориентированные приложения были намного меньше по размеру, и весь код приложения разрабатывался в одной компании. Разумеется, в то время уже были операционные системы, позволяющие приложениям по максимуму использовать их возможности, но современные ОС предлагают намного больше функций.",
    "Chapter": 6,
    "Page": 196
  },
  {
    "Text": "В .NET номер версии состоит из четырех частей: основного (major) и дополнительного (minor) номеров версии, номера построения (build) и номера редакции (revision). Например, у сборки с номером 1.2.3.4 основной номер версии \u2014 1, до- полнительный номер версии \u2014 2, номер построения \u2014 3 и номер редакции \u2014 4. Основной и дополнительный номера обычно определяют уникальность сборки, а номера построения и редакции указывают на служебную версию",
    "Chapter": 6,
    "Page": 197
  },
  {
    "Text": "При компиляции этого кода компилятор помещает три записи в таблицу опре- делений методов сборки. Каждая запись содержит флаги, указывающие, является ли метод экземплярным, виртуальным или статическим. При компиляции кода, ссылающегося на эти методы, компилятор проверяет флаги в определении методов, чтобы выяснить, какой IL-код нужно вставить для корректного вызова методов. ",
    "Chapter": 6,
    "Page": 199
  },
  {
    "Text": "В .NET Framework приложения состоят из типов, определенных в многочисленных сборках, созданных различными компаниями. Это означает практически полное отсутствие контроля над используемыми компонентами и типами. Разработчику обычно недоступен исходный код компонентов (он может даже не знать, на каком языке они написаны), к тому же версии компонентов обновляются в разное время. Более того, из-за полиморфизма и наличия защищенных членов разработчик базового класса должен доверять коду разработчика производного класса. В свою очередь, разработчик производного класса должен доверять коду, наследуемому от 203Компоненты,.полиморфизм.и.версии базового класса. Это лишь часть ограничений, с которыми приходится сталкиваться при разработке компонентов и типов.",
    "Chapter": 6,
    "Page": 202
  },
  {
    "Text": "Если класс не предназначен для наследования, я всегда явно объявляю его запечатанным. Как уже отмечалось, C# и многие современные компиляторы поступают иначе. Если нет необходимости в предоставлении другим сборкам доступа к классу, он объявляется внутренним. К счастью, именно так ведет себя по умолчанию компилятор C#. Если я хочу определить класс, предназначенный для создания производных классов, одновременно запретив его специализацию, я должен переопределить и запечатать все виртуальные методы, которые на- следует мой класс.",
    "Chapter": 6,
    "Page": 204
  },
  {
    "Text": "Константа (constant) \u2014 это идентификатор, значение которого никогда не меняется. Значение, связанное с именем константы, должно определяться во время компиляции. Затем компилятор сохраняет значение константы в метаданных модуля. Это значит, что константы можно определять только для таких типов, которые компилятор считает примитивными. В C# следующие типы считаются примитивными и могут использоваться для определения констант: Boolean, Char, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Decimal и String. Тем не менее C# позволяет определить константную переменную, не относящуюся к элементарному типу, если присвоить ей значение null",
    "Chapter": 7,
    "Page": 210
  },
  {
    "Text": "Встретив в исходном тексте имя константы, компилятор просматривает метаданные модуля, в котором она определена, извлекает значение константы и внедряет его в генерируемый им IL-код. Поскольку значение константы внедряется прямо в код, в период выполнения память для констант не выделяется. Кроме того, нельзя получать адрес константы и передавать ее по ссылке. Эти ограничения также означают, что изменять значения константы в разных версиях модуля нельзя, поэтому константу надо использовать, только когда точно известно, что ее значение никогда не изменится (хороший пример \u2014 определение константы MaxInt16 со значением 32767). ",
    "Chapter": 7,
    "Page": 210
  },
  {
    "Text": "Поскольку поля хранятся в динамической памяти, их значения можно получить лишь в период выполнения. Поля также решают проблему управления версиями, возникающую при использовании констант. Кроме того, полю можно назначить любой тип данных, поэтому при определении полей можно не ограничиваться встроенными элементарными типами компилятора (что приходится делать при определении констант).",
    "Chapter": 7,
    "Page": 212
  },
  {
    "Text": "При конструировании объекта ссылочного типа выделяемая для него память всегда обнуляется до вызова конструктора экземпляра типа. Любые поля, не задаваемые конструктором явно, гарантированно содержат 0 или null.",
    "Chapter": 8,
    "Page": 215
  },
  {
    "Text": "Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут  повлиять на создаваемый объект. Причина проста: если вызываемый виртуальный  метод переопределен в типе, экземпляр которого создается, происходит реализа- ция производного типа, но к этому моменту еще не завершилась инициализация  всех полей в иерархии.  В таких обстоятельствах последствия вызова виртуального  метода непредсказуемы",
    "Chapter": 8,
    "Page": 216
  },
  {
    "Text": "Конструкторы значимых типов (struct) работают иначе, чем ссылочных (class). CLR всегда разрешает создание экземпляров значимых типов и этому ничто не может помешать. Поэтому, по большому счету, конструкторы у значимого типа можно не определять. Фактически многие компиляторы (включая C#) не опреде- ляют для значимых типов конструкторы по умолчанию, не имеющие параметров.",
    "Chapter": 8,
    "Page": 219
  },
  {
    "Text": "C# преднамеренно запрещает определять конструкторы без параметров у значимых типов, чтобы не вводить разработчиков в заблуждение относительно того, какой конструктор вызывается. ",
    "Chapter": 8,
    "Page": 220
  },
  {
    "Text": "Помимо конструкторов экземпляров, CLR поддерживает конструкторы типов (также известные как статические конструкторы, конструкторы классов и инициализаторы типов). Конструкторы типов можно применять и к интерфейсам (хотя C# этого не допускает), ссылочным и значимым типам. Подобно тому, как конструкторы экземпляров используются для установки первоначального состояния экземпляра типа, конструкторы типов служат для установки первоначального состояния типа. По умолчанию у типа не определено конструктора. У типа не может быть более одного конструктора; кроме того, у конструкторов типов никогда не бывает параметров. ",
    "Chapter": 8,
    "Page": 222
  },
  {
    "Text": "В некоторых языках тип может определять, как операторы должны манипулировать его экземплярами. В частности, многие типы (например, System.String, System. Decimal и System.DateTime) используют перегрузку операторов равенства (==) и неравенства (!=). CLR ничего не известно о перегрузке операторов \u2014 ведь среда даже не знает, что такое оператор. Смысл операторов и код, который должен быть сгенерирован, когда тот или иной оператор встретится в исходном тексте, определяется языком программирования.",
    "Chapter": 8,
    "Page": 226
  },
  {
    "Text": "Компилятор C# полностью поддерживает операторы преобразования. Обнаружив код, в котором вместо ожидаемого типа используется объект совсем другого типа, компилятор ищет метод оператора неявного преобразования, способный выполнить нужное преобразование, и генерирует код, вызывающий этот метод. Если подходящий метод оператора неявного преобразования обнаруживается, компилятор вставляет в результирующий IL-код вызов этого метода. Найдя в исходном тексте явное приведение типов, компилятор ищет метод оператора явного или неявного преобразования. Если он существует, компилятор генерирует вызывающий его код. Если компилятор не может найти подходящий метод оператора преобразования, он выдает ошибку, и код не компилируется.",
    "Chapter": 8,
    "Page": 233
  },
  {
    "Text": "Чтобы по-настоящему разобраться в методах перегруженных операторов и операторов преобразования, я настоятельно рекомендую использовать тип System. Decimal как образец. В типе Decimal определено несколько конструкторов, позволяющих преобразовывать в Decimal объекты различных типов. Он также поддерживает несколько методов ToXxx для преобразования объектов типа Decimal в объекты других типов. Наконец, в этом типе определен ряд методов операторов преобразования и перегруженных операторов.",
    "Chapter": 8,
    "Page": 234
  },
  {
    "Text": "Язык С# поддерживает только методы расширения, он не поддерживает свойств расширения, событий расширения, операторов расширения и т. д.",
    "Chapter": 8,
    "Page": 237
  },
  {
    "Text": "При выборе параметров метода некоторым из них (и даже всем) можно присваивать значения по умолчанию. В результате в вызывающем такой метод коде можно не указывать эти аргументы, а принимать уже имеющиеся значения. Кроме того, при вызове метода существует возможность указать аргументы, воспользовавшись именами их параметров. ",
    "Chapter": 9,
    "Page": 245
  },
  {
    "Text": "Во время компиляции значения по умолчанию должны оставаться неизменными. То есть задавать значения по умолчанию можно для параметров примитивных типов, перечисленных в табл. 5.1 главы 5. Сюда относятся также перечислимые типы и ссылочные типы, допускающие присвоение значения null. ",
    "Chapter": 9,
    "Page": 246
  },
  {
    "Text": "По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу передается ссылка (или указатель) на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта, а исходный экземпляр сохраняется неизменным.",
    "Chapter": 9,
    "Page": 251
  },
  {
    "Text": "CLR также позволяет передавать параметры по ссылке, а не по значению. В C# это делается с помощью ключевых слов out и ref. Оба заставляют компилятор генерировать метаданные, описывающие параметр как переданный по ссылке. Компилятор использует эти метаданные для генерирования кода, передающего вместо самого параметра его адрес.",
    "Chapter": 9,
    "Page": 251
  },
  {
    "Text": "Передача.параметров.в.метод.по.ссылке Передача параметров в метод по ссылке По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу передается ссылка (или указатель) на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта, а исходный экземпляр сохраняется неизменным. Вниманиею Следует знать тип каждого объекта, передаваемого методу в качестве параметра, поскольку манипулирующий параметрами код может существенно различаться в зависимости от типа параметров CLR также позволяет передавать параметры по ссылке, а не по значению. В C# это делается с помощью ключевых слов out и ref. Оба заставляют компилятор генерировать метаданные, описывающие параметр как переданный по ссылке. Компилятор использует эти метаданные для генерирования кода, передающего вместо самого параметра его адрес. С точки зрения CLR, ключевые слова out и ref не различаются, то есть для них генерируются одинаковый IL-код, а метаданные отличаются всего одним битом, указывающим, какое ключевое слово было использовано при объявлении метода. Однако компилятор C# различает эти ключевые слова при выборе метода, исполь- зуемого для инициализации объекта, на который указывает переданная ссылка. Если параметр метода помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод. В этом случае вызванный метод не может прочитать значение параметра и должен записать его, прежде чем вернуть управление. Если же параметр помечен ключевым словом ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод может как читать, так и записывать значение параметра",
    "Chapter": 9,
    "Page": 251
  },
  {
    "Text": "Меня часто спрашивают, почему при вызовах методов в программах на C# надо в явном  виде указывать ключевые слова out или ref. В конце концов, компилятор в состоянии  самостоятельно определить, какое из ключевых слов ему требуется, а значит, должен  корректно компилировать код. Однако разработчики C# сочли, что вызывающий код  должен явно указывать свои намерения, чтобы при вызове метода сразу было ясно, что этот метод должен менять значение передаваемой переменной",
    "Chapter": 9,
    "Page": 253
  },
  {
    "Text": "Можно считать свойства \u00ABумными\u00BB полями, то есть полями с дополнительной логикой. CLR поддерживает статические, экземплярные, абстрактные и виртуальные свойства. Кроме того, свойства могут помечаться модификатором доступа (см. главу 6) и определяться в интерфейсах (см. главу 13).",
    "Chapter": 10,
    "Page": 266
  },
  {
    "Text": "Лично мне свойства не нравятся и я был бы рад, если бы в Microsoft решили убрать их поддержку из .NET Framework и сопутствующих языков программирования. Причина в том, что свойства выглядят как поля, являясь по сути методами. Это порождает немыслимую путаницу. Столкнувшись с кодом, который вроде бы обращается к полю, разработчик привычно предполагает наличие множества условий, которые далеко не всегда соблюдаются, если речь идет о свойстве.",
    "Chapter": 10,
    "Page": 267
  },
  {
    "Text": "Я считаю, что разработчики используют свойства намного чаще, чем следовало бы",
    "Chapter": 10,
    "Page": 270
  },
  {
    "Text": "Механизм анонимных типов в С# позволяет автоматически объявить кортежный тип при помощи простого синтаксиса. Кортежный тип (tuple type) \u2014 это тип, который содержит коллекцию свойств, каким-то образом связанных друг с другом. ",
    "Chapter": 10,
    "Page": 273
  },
  {
    "Text": "Компилятор очень разумно выясняет анонимный тип. Если компилятор видит, что вы определили множество анонимных типов с идентичными структурами, то он создает одно определение для анонимного типа и множество экземпляров этого типа. Под одинаковой структурой я подразумеваю, что анонимные типы имеют одинаковые тип и имя для каждого свойства и что эти свойства определены в одинаковом порядке. ",
    "Chapter": 10,
    "Page": 275
  },
  {
    "Text": "У свойств, рассмотренных в предыдущем разделе, методы доступа get не принимали параметры. Поэтому я называю их свойствами без параметров (parameterless properties). Они проще, так как их использование напоминает обращение к полю. Помимо таких \u00ABполеобразных\u00BB свойств, языки программирования поддерживают то, что я называю свойствами с параметрами (parameterful properties). У таких свойств методы доступа get получают один или несколько параметров. ",
    "Chapter": 10,
    "Page": 279
  },
  {
    "Text": "Поскольку свойства фактически представляют собой методы, а C# и CLR поддерживают параметризацию методов, некоторые разработчики пытаются определить свойства с собственными параметрами-типами (вместо использования таких параметров из внешнего типа). Однако C# не позволяет этого делать. Главная причина в том, что обобщения свойств лишены смысла с концептуальной точки зрения. Предполагается, что свойство представляет характеристику объекта, которую мож- но прочитать или задать. Введение обобщенного параметра типа означало бы, что поведение операции чтения/записи может меняться, но на концептуальном уровне от свойства не ожидается никакого поведения. Для задания какого-либо поведения объекта (обобщенного или нет) следует создать метод, а не свойство",
    "Chapter": 10,
    "Page": 285
  }
]